import "trust-graph.aqua"
import "misc.aqua"
import Sig, Peer from "@fluencelabs/aqua-lib/builtin.aqua"

alias PeerId: string
alias Error: string

-- Set peer_id as a root to TG instance on current node
-- Self-signed trust should be added in next call for correct behaviour
-- `max_chain_len` specifies maximum chain length after root trust,
-- if `max_chain_len` is zero there is no trusts except self-signed root trust in certificates for this root
func set_root(peer_id: PeerId, max_chain_len: u32) -> SetRootResult:
    result <- TrustGraph.set_root(peer_id, max_chain_len)
    <- result

-- Create and sign trust with private key from 'sig_id' service
-- If `sig_id` is nil, default Sig service will be used with %init_peer_id% private key
func issue_trust(issued_for: PeerId, expires_at_sec: u64, sig_id: ?string) -> ?Trust, ?Error:
    on HOST_PEER_ID:
        issued_at_sec <- Peer.timestamp_sec()
        bytes <- TrustGraph.get_trust_bytes(issued_for, expires_at_sec, issued_at_sec)

    result: ?Trust
    error: ?string
    if bytes.success:
        sig_service: ?string
        if sig_id != nil:
            sig_service <<- sig_id!
        else:
            sig_service <<- "sig"

        Sig sig_service!
        signature <- Sig.sign(bytes.result)

        on HOST_PEER_ID:
            issue_result <- TrustGraph.issue_trust(issued_for, expires_at_sec, issued_at_sec, signature)
        if issue_result.success:
            result <<- issue_result.trust
        else:
            error <<- issue_result.error
    else:
        error <<- bytes.error
    <- result, error

-- Add trust to TG instance on current node
func import_trust(trust: Trust, issuer: PeerId) -> ?Error:
    error: ?string
    timestamp_sec <- Peer.timestamp_sec()
    add_result <- TrustGraph.add_trust(trust, issuer, timestamp_sec)
    if add_result.success != true:
        error <<- add_result.error
    <- error

-- Issue trust and add to TG instance on `node`
-- If `issuer` != %init_peer_id%, Sig service should be registered with issuer's peer id as a service id.
func add_trust(node: PeerId, issuer: PeerId, issued_for: PeerId, expires_at_sec: u64) -> ?Error:
    sig_service: ?string
    if issuer != %init_peer_id%:
        sig_service <<- issuer

    trust, issue_error <- issue_trust(issued_for, expires_at_sec, sig_service)

    error: *?Error
    if trust == nil:
        error <<- issue_error
    else:
        on node:
            error <- import_trust(trust!, issuer)

    <- error!

-- Set `peer_id` as a root and add self-signed trust to TG instance on `node`
-- If `peer_id` != %init_peer_id%, Sig service should be registered with this peer id as a service id.
func add_root_trust(node: PeerId, peer_id: PeerId, max_chain_len: u32, expires_at_sec: u64) -> ?Error:
    sig_service: ?string
    if peer_id != %init_peer_id%:
        sig_service <<- peer_id

    trust, issue_error <- issue_trust(peer_id, expires_at_sec, sig_service)

    error: *?Error
    if trust == nil:
        error <<- issue_error
    else:
        on node:
            set_root_result <- set_root(peer_id, max_chain_len)
            if set_root_result.success:
                error <- import_trust(trust!, peer_id)
            else:
                -- converting string to ?string
                tmp: *string
                tmp <<- set_root_result.error
                error <<- tmp

    <- error!

-- Check signature and expiration time of trust
func verify_trust(trust: Trust, issuer: PeerId) -> VerifyTrustResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.verify_trust(trust, issuer, timestamp_sec)
    <- result

-- Get the maximum weight of trust for one peer id
-- Trust has weight if there is at least 1 trust chain from one of the roots
func get_weight(peer_id: PeerId) -> WeightResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_weight(peer_id, timestamp_sec)
    <- result

-- Get maximum weight of trust among all chains which contain trust from `issuer`
func get_weight_from(peer_id: PeerId, issuer: PeerId) -> WeightResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_weight_from(peer_id, issuer, timestamp_sec)
    <- result

-- Create revocation signed by %init_peer_id%
-- If `sig_id` is nil, default Sig service will be used with %init_peer_id% private key
func issue_revocation(revoked_by: PeerId, revoked: PeerId, sig_id: ?string) -> ?Revocation, ?Error:
    on HOST_PEER_ID:
        issued_at_sec <- Peer.timestamp_sec()
        bytes <- TrustGraph.get_revocation_bytes(revoked, issued_at_sec)

    result: ?Revocation
    error: ?string
    if bytes.success:
        sig_service: ?string
        if sig_id != nil:
            sig_service <<- sig_id!
        else:
            sig_service <<- "sig"

        Sig sig_service!
        signature <- Sig.sign(bytes.result)

        on HOST_PEER_ID:
            issue_result <- TrustGraph.issue_revocation(revoked_by, revoked, issued_at_sec, signature)
        if issue_result.success:
            result <<- issue_result.revocation
        else:
            error <<- issue_result.error
    else:
        error <<- bytes.error
    <- result, error

-- Import revocation to current node's TG instance
func import_revocation(revocation: Revocation) -> ?Error:
    error: ?string
    timestamp_sec <- Peer.timestamp_sec()
    add_result <- TrustGraph.revoke(revocation, timestamp_sec)
    if add_result.success != true:
        error <<- add_result.error

    <- error

-- Revoke all certificates on `node` TG instance
-- which contain path from %init_peer_id% to `revoked_peer_id`
-- If `revoked_by` != %init_peer_id%, Sig service should be registered with this peer id as a service id.
func revoke(node: PeerId, revoked_by: PeerId, revoked: PeerId) -> ?Error:
    sig_service: ?string
    if revoked_by != %init_peer_id%:
        sig_service <<- revoked_by

    revocation, issue_error <- issue_revocation(revoked_by, revoked, sig_service)

    error: *?string
    if revocation == nil:
        error <<- issue_error
    else:
        on node:
           error <- import_revocation(revocation!)

    <- error!



-- Return all certificates issued for current node which contains trust from `issuer`
func get_host_certs_from(issuer: PeerId) -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_host_certs_from(issuer, timestamp_sec)
    <- result

-- Return all certificates issued for given peer id
func get_all_certs(issued_for: PeerId) -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_all_certs(issued_for, timestamp_sec)
    <- result

-- Return all certificates issued for given peer id which contains trust from `issuer`
func get_all_certs_from(issued_for: PeerId, issuer: PeerId) -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_all_certs_from(issued_for, issuer, timestamp_sec)
    <- result

-- Return all certificates issued for current node
func get_host_certs() -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_host_certs(timestamp_sec)
    <- result

-- Insert certificate to TG instance on current node
func insert_cert(certificate: Certificate) -> InsertResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.insert_cert(certificate, timestamp_sec)
    <- result

-- returns `true` if current node is identified as official Fluence Labs peer
-- returns `false` otherwise
func isFluencePeer() -> ?bool, ?Error:
    certs_result <- get_host_certs_from("12D3KooWM45u7AQxsb4MuQJNYT3NWHHMLU7JTbBV66RTfF3KSzdR")
    result: ?bool
    error: ?string
    if certs_result.success:
        for cert  <- certs_result.certificates:
            len <- TrustOp.array_length(cert.chain)
            if len == 3:
                if cert.chain!0.issued_for == "12D3KooWNbZKaPWRZ8wgjGvrxdJFz9Fq5uVwkR6ERV1f74HhPdyB":
                    if cert.chain!1.issued_for == "12D3KooWM45u7AQxsb4MuQJNYT3NWHHMLU7JTbBV66RTfF3KSzdR":
                        result <<- true
        if result == nil:
            result <<- false
    else:
        error <<- certs_result.error
    <- result, error

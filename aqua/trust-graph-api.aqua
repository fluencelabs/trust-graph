import "trust-graph.aqua"
import "misc.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"

-- Set peer_id as a root to TG instance on current node
-- Self-signed trust should be added in next call for correct behaviour
-- `max_chain_len` specifies maximum chain length after root trust,
-- if `max_chain_len` is zero there is no trusts except self-signed root trust in certificates for this root
func add_root(peer_id: string, max_chain_len: u32) -> AddRootResult:
    weight_factor <- TrustGraph.get_weight_factor(max_chain_len)
    result <- TrustGraph.add_root(peer_id, weight_factor)
    <- result

-- Create and sign trust with %init_peer_id%'s private key
func issue_trust(issued_for_peer_id: string, expires_at_sec: u64) -> ?Trust, ?string:
    issued_at_sec <- Peer.timestamp_sec()
    bytes <- TrustGraph.get_trust_bytes(issued_for_peer_id, expires_at_sec, issued_at_sec)

    result: ?Trust
    error: ?string
    if bytes.success:
        on %init_peer_id% via HOST_PEER_ID:
            signature <- Sig.sign(bytes.result)
        issue_result <- TrustGraph.issue_trust(issued_for_peer_id, expires_at_sec, issued_at_sec, signature)
        if issue_result.success:
            result <<- issue_result.trust
        else:
            error <<- issue_result.error
    else:
        error <<- bytes.error
    <- result, error

-- Issue trust and add to TG instance on current node
func add_trust(issued_for_peer_id: string, expires_at_sec: u64) -> ?string:
    trust, issue_error <- issue_trust(issued_for_peer_id, expires_at_sec)

    error: ?string
    if trust == nil:
        error <<- issue_error!
    else:
        timestamp_sec <- Peer.timestamp_sec()
        add_result <- TrustGraph.add_trust(trust!, %init_peer_id%, timestamp_sec)
        if add_result.success != true:
            error <<- add_result.error

    <- error

-- Add trust to TG instance on current node
func import_trust(trust: Trust) -> ?string:
    error: ?string
    timestamp_sec <- Peer.timestamp_sec()
    add_result <- TrustGraph.add_trust(trust, %init_peer_id%, timestamp_sec)
    if add_result.success != true:
        error <<- add_result.error

    <- error

-- Set %init_peer_id% as a root and add self-signed trust to TG instance on current node
func add_root_trust(max_chain_len: u32, expires_at_sec: u64) -> ?string:
    add_root_result <- add_root(%init_peer_id%, max_chain_len)
    error: *?string
    if add_root_result.success:
        error <- add_trust(%init_peer_id%, expires_at_sec)
    else:
        -- converting string to ?string
        tmp: *string
        tmp <<- add_root_result.error
        error <<- tmp

    <- error!

-- Check signature and expiration time of trust
func verify_trust(trust: Trust, issuer_peer_id: string) -> VerifyTrustResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.verify_trust(trust, issuer_peer_id, timestamp_sec)
    <- result

-- Get the maximum weight of trust for one peer id
-- Trust has weight if there is at least 1 trust chain from one of the roots
func get_weight(peer_id: string) -> WeightResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_weight(peer_id, timestamp_sec)
    <- result

-- Get maximum weight of trust among all chains which contain trust from `issuer`
func get_weight_from(peer_id: string, issuer: string) -> WeightResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_weight_from(peer_id, issuer, timestamp_sec)
    <- result

-- Create revocation signed by %init_peer_id%
func issue_revocation(revoked_peer_id: string) -> ?Revocation, ?string:
    issued_at_sec <- Peer.timestamp_sec()
    bytes <- TrustGraph.get_revocation_bytes(revoked_peer_id, issued_at_sec)

    result: ?Revocation
    error: ?string
    if bytes.success:
        on %init_peer_id% via HOST_PEER_ID:
            signature <- Sig.sign(bytes.result)
        issue_result <- TrustGraph.issue_revocation(revoked_peer_id, %init_peer_id%, issued_at_sec, signature)
        if issue_result.success:
            result <<- issue_result.revocation
        else:
            error <<- issue_result.error
    else:
        error <<- bytes.error
    <- result, error

-- Revoke all certificates on current node's TG instance
-- which contain path from %init_peer_id% to `revoked_peer_id`
func revoke(revoked_peer_id: string) -> ?string:
    revocation, issue_error <- issue_revocation(revoked_peer_id)

    error: ?string
    if revocation == nil:
        error <<- issue_error!
    else:
        timestamp_sec <- Peer.timestamp_sec()
        revoke_result <- TrustGraph.revoke(revocation!, timestamp_sec)
        if revoke_result.success != true:
            error <<- revoke_result.error

    <- error

-- Import revocation to current node's TG instance
func import_revocation(revocation: Revocation) -> ?string:
    error: ?string
    timestamp_sec <- Peer.timestamp_sec()
    add_result <- TrustGraph.revoke(revocation, timestamp_sec)
    if add_result.success != true:
        error <<- add_result.error

    <- error

-- Return all certificates issued for current node which contains trust from `issuer`
func get_host_certs_from(issuer: string) -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_host_certs_from(issuer, timestamp_sec)
    <- result

-- Return all certificates issued for given peer id
func get_all_certs(issued_for: string) -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_all_certs(issued_for, timestamp_sec)
    <- result

-- Return all certificates issued for given peer id which contains trust from `issuer`
func get_all_certs_from(issued_for: string, issuer: string) -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_all_certs_from(issued_for, issuer, timestamp_sec)
    <- result

-- Return all certificates issued for current node
func get_host_certs() -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_host_certs(timestamp_sec)
    <- result

-- Insert certificate to TG instance on current node
func insert_cert(certificate: Certificate) -> InsertResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.insert_cert(certificate, timestamp_sec)
    <- result

-- returns `true` if current node is identified as official Fluence Labs peer
-- returns `false` otherwise
func isFluencePeer() -> ?bool, ?string:
    certs_result <- get_host_certs_from("12D3KooWM45u7AQxsb4MuQJNYT3NWHHMLU7JTbBV66RTfF3KSzdR")
    result: ?bool
    error: ?string
    if certs_result.success:
        for cert  <- certs_result.certificates:
            len <- TrustOp.array_length(cert.chain)
            if len == 3:
                if cert.chain!0.issued_for == "12D3KooWNbZKaPWRZ8wgjGvrxdJFz9Fq5uVwkR6ERV1f74HhPdyB":
                    if cert.chain!1.issued_for == "12D3KooWM45u7AQxsb4MuQJNYT3NWHHMLU7JTbBV66RTfF3KSzdR":
                        result <<- true
        if result == nil:
            result <<- false
    else:
        error <<- certs_result.error
    <- result, error

import "trust-graph.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"

func add_root(peer_id: string, max_chain_len: u32) -> AddRootResult:
    weight_factor <- TrustGraph.get_weight_factor(max_chain_len)
    result <- TrustGraph.add_root(peer_id, weight_factor)
    <- result

func get_weight(peer_id: string) -> WeightResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_weight(peer_id, timestamp_sec)
    <- result

func issue_trust(issued_for_peer_id: string, expires_at_sec: u64) -> ?Trust, ?string:
    issued_at_sec <- Peer.timestamp_sec()
    bytes <- TrustGraph.get_trust_bytes(issued_for_peer_id, expires_at_sec, issued_at_sec)

    result: ?Trust
    error: ?string
    if bytes.success:
        on %init_peer_id% via HOST_PEER_ID:
            signature <- Sig.sign(bytes.result)
        issue_result <- TrustGraph.issue_trust(issued_for_peer_id, expires_at_sec, issued_at_sec, signature)
        if issue_result.success:
            result <<- issue_result.trust
        else:
            error <<- issue_result.error
    else:
        error <<- bytes.error
    <- result, error

func add_trust(issued_for_peer_id: string, expires_at_sec: u64) -> ?string:
    trust, issue_error <- issue_trust(issued_for_peer_id, expires_at_sec)

    error: ?string
    if trust == nil:
        error <<- issue_error!
    else:
        timestamp_sec <- Peer.timestamp_sec()
        add_result <- TrustGraph.add_trust(trust!, %init_peer_id%, timestamp_sec)
        if add_result.success != true:
            error <<- add_result.error

    <- error

func add_root_trust(max_chain_len: u32, expires_at_sec: u64) -> ?string:
    add_root_result <- add_root(%init_peer_id%, max_chain_len)
    error: *?string
    if add_root_result.success:
        error <- add_trust(%init_peer_id%, expires_at_sec)
    else:
        -- converting string to ?string
        tmp: *string
        tmp <<- add_root_result.error
        error <<- tmp

    <- error!

func import_trust(trust: Trust) -> ?string:
    error: ?string
    timestamp_sec <- Peer.timestamp_sec()
    add_result <- TrustGraph.add_trust(trust, %init_peer_id%, timestamp_sec)
    if add_result.success != true:
        error <<- add_result.error

    <- error

func verify_trust(trust: Trust, issuer_peer_id: string) -> VerifyTrustResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.verify_trust(trust, issuer_peer_id, timestamp_sec)
    <- result

func issue_revocation(revoked_peer_id: string) -> ?Revocation, ?string:
    issued_at_sec <- Peer.timestamp_sec()
    bytes <- TrustGraph.get_revocation_bytes(revoked_peer_id, issued_at_sec)

    result: ?Revocation
    error: ?string
    if bytes.success:
        on %init_peer_id% via HOST_PEER_ID:
            signature <- Sig.sign(bytes.result)
        issue_result <- TrustGraph.issue_revocation(revoked_peer_id, %init_peer_id%, issued_at_sec, signature)
        if issue_result.success != true:
            result <<- issue_result.revocation
        else:
            error <<- issue_result.error
    else:
        error <<- bytes.error
    <- result, error

func revoke(revoked_peer_id: string) -> ?string:
    revocation, issue_error <- issue_revocation(revoked_peer_id)

    error: ?string
    if revocation == nil:
        error <<- issue_error!
    else:
        timestamp_sec <- Peer.timestamp_sec()
        add_result <- TrustGraph.revoke(revocation!, timestamp_sec)
        if add_result.success != true:
            error <<- add_result.error

    <- error


func import_revocation(revocation: Revocation) -> ?string:
    error: ?string
    timestamp_sec <- Peer.timestamp_sec()
    add_result <- TrustGraph.revoke(revocation, timestamp_sec)
    if add_result.success != true:
        error <<- add_result.error

    <- error

func get_host_certs_from(issuer: string) -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_host_certs_from(issuer, timestamp_sec)
    <- result

func get_all_certs(issued_for: string) -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_all_certs(issued_for, timestamp_sec)
    <- result

func get_host_certs() -> AllCertsResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.get_host_certs(timestamp_sec)
    <- result

func insert_cert(certificate: Certificate) -> InsertResult:
    timestamp_sec <- Peer.timestamp_sec()
    result <- TrustGraph.insert_cert(certificate, timestamp_sec)
    <- result

-- helpers for isFluencePeer
service TrustOp("op"):
  array_length(a: []Trust) -> u32

service BoolOp("op"):
  array_length(a: []bool) -> u32

-- returns `true` if current relay is identified as official Fluence Labs peer
-- returns `false` otherwise
func isFluencePeer() -> ?bool, ?string:
    certs_result <- get_host_certs_from("12D3KooWM45u7AQxsb4MuQJNYT3NWHHMLU7JTbBV66RTfF3KSzdR")
    result: ?bool
    error: ?string
    if certs_result.success:
        for cert  <- certs_result.certificates:
            len <- TrustOp.array_length(cert.chain)
            if len == 3:
                if cert.chain!0.issued_for == "12D3KooWNbZKaPWRZ8wgjGvrxdJFz9Fq5uVwkR6ERV1f74HhPdyB":
                    if cert.chain!1.issued_for == "12D3KooWM45u7AQxsb4MuQJNYT3NWHHMLU7JTbBV66RTfF3KSzdR":
                        result <<- true
        if result == nil:
            result <<- false
    else:
        error <<- certs_result.error
    <- result, error

-- labels: example with 3 node trusts/revocations, execution of some conditional code
-- weights:
--    if registry is ready:
--      - can't add record
--      - after issuing trust you can
--    if not:
--      - price-oracle average: on local tg get weight, check tetraplets, calculate average, etc
-- weights: demo with connectivity [later]
-- permissions control - registry